// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`


`include "common_cells/assertions.svh"

module conv1d_control_reg_top #(
  parameter type reg_req_t = logic,
  parameter type reg_rsp_t = logic,
  parameter int AW = 4
) (
  input                                                  clk_i,
  input                                                  rst_ni,
  input  reg_req_t                                       reg_req_i,
  output reg_rsp_t                                       reg_rsp_o,
  // To HW
  output conv1d_control_reg_pkg::conv1d_control_reg2hw_t reg2hw,     // Write
  input  conv1d_control_reg_pkg::conv1d_control_hw2reg_t hw2reg,     // Read


  // Config
  input devmode_i  // If 1, explicit error return for unmapped register access
);

  import conv1d_control_reg_pkg::*;

  localparam int DW = 32;
  localparam int DBW = DW / 8;  // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [ AW-1:0] reg_addr;
  logic [ DW-1:0] reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [ DW-1:0] reg_rdata;
  logic           reg_error;

  logic addrmiss, wr_err;

  logic     [DW-1:0] reg_rdata_next;

  // Below register interface can be changed
  reg_req_t          reg_intf_req;
  reg_rsp_t          reg_intf_rsp;


  assign reg_intf_req       = reg_req_i;
  assign reg_rsp_o          = reg_intf_rsp;


  assign reg_we             = reg_intf_req.valid & reg_intf_req.write;
  assign reg_re             = reg_intf_req.valid & ~reg_intf_req.write;
  assign reg_addr           = reg_intf_req.addr;
  assign reg_wdata          = reg_intf_req.wdata;
  assign reg_be             = reg_intf_req.wstrb;
  assign reg_intf_rsp.rdata = reg_rdata;
  assign reg_intf_rsp.error = reg_error;
  assign reg_intf_rsp.ready = 1'b1;

  assign reg_rdata          = reg_rdata_next;
  assign reg_error          = (devmode_i & addrmiss) | wr_err;


  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
  logic       control_start_qs;
  logic       control_start_wd;
  logic       control_start_we;
  logic       control_mcu_using_sram_qs;
  logic       control_mcu_using_sram_wd;
  logic       control_mcu_using_sram_we;
  logic       control_loaded_flag_qs;
  logic       control_loaded_flag_wd;
  logic       control_loaded_flag_we;
  logic       status1_running_qs;
  logic       status1_running_wd;
  logic       status1_running_we;
  logic       status1_done_qs;
  logic       status1_done_wd;
  logic       status1_done_we;
  logic       status1_accelerator_using_sram_qs;
  logic       status1_accelerator_using_sram_wd;
  logic       status1_accelerator_using_sram_we;
  logic       status1_reload_flag_qs;
  logic       status1_reload_flag_wd;
  logic       status1_reload_flag_we;
  logic       status1_done_calculation_qs;
  logic       status1_done_calculation_wd;
  logic       status1_done_calculation_we;
  logic       status1_done_filter_qs;
  logic       status1_done_filter_wd;
  logic       status1_done_filter_we;
  logic [2:0] status1_filter_number_sram_qs;
  logic [2:0] status1_filter_number_sram_wd;
  logic       status1_filter_number_sram_we;
  logic [2:0] status1_data_number_sram_qs;
  logic [2:0] status1_data_number_sram_wd;
  logic       status1_data_number_sram_we;
  logic [1:0] status1_lego_number_din_qs;
  logic [1:0] status1_lego_number_din_wd;
  logic       status1_lego_number_din_we;
  logic [1:0] status1_lego_number_weights_qs;
  logic [1:0] status1_lego_number_weights_wd;
  logic       status1_lego_number_weights_we;
  logic [4:0] status1_lego_tower_din_qs;
  logic [4:0] status1_lego_tower_din_wd;
  logic       status1_lego_tower_din_we;
  logic [7:0] status2_din_address_qs;
  logic [7:0] status2_din_address_wd;
  logic       status2_din_address_we;
  logic [7:0] status2_dout_address_qs;
  logic [7:0] status2_dout_address_wd;
  logic       status2_dout_address_we;
  logic [7:0] status2_weight_address_qs;
  logic [7:0] status2_weight_address_wd;
  logic       status2_weight_address_we;

  // Register instances
  // R[control]: V(False)

  //   F[start]: 0:0
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_control_start (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(control_start_we),
    .wd(control_start_wd),

    // from internal hardware
    .de(1'b0),
    .d ('0),

    // to internal hardware
    .qe(),
    .q (reg2hw.control.start.q),

    // to register interface (read)
    .qs(control_start_qs)
  );


  //   F[mcu_using_sram]: 1:1
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_control_mcu_using_sram (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(control_mcu_using_sram_we),
    .wd(control_mcu_using_sram_wd),

    // from internal hardware
    .de(1'b0),
    .d ('0),

    // to internal hardware
    .qe(),
    .q (reg2hw.control.mcu_using_sram.q),

    // to register interface (read)
    .qs(control_mcu_using_sram_qs)
  );


  //   F[loaded_flag]: 2:2
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_control_loaded_flag (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(control_loaded_flag_we),
    .wd(control_loaded_flag_wd),

    // from internal hardware
    .de(1'b0),
    .d ('0),

    // to internal hardware
    .qe(),
    .q (reg2hw.control.loaded_flag.q),

    // to register interface (read)
    .qs(control_loaded_flag_qs)
  );


  // R[status1]: V(False)

  //   F[running]: 0:0
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_running (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_running_we),
    .wd(status1_running_wd),

    // from internal hardware
    .de(hw2reg.status1.running.de),
    .d (hw2reg.status1.running.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.running.q),

    // to register interface (read)
    .qs(status1_running_qs)
  );


  //   F[done]: 1:1
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_done (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_done_we),
    .wd(status1_done_wd),

    // from internal hardware
    .de(hw2reg.status1.done.de),
    .d (hw2reg.status1.done.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.done.q),

    // to register interface (read)
    .qs(status1_done_qs)
  );


  //   F[accelerator_using_sram]: 2:2
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_accelerator_using_sram (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_accelerator_using_sram_we),
    .wd(status1_accelerator_using_sram_wd),

    // from internal hardware
    .de(hw2reg.status1.accelerator_using_sram.de),
    .d (hw2reg.status1.accelerator_using_sram.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.accelerator_using_sram.q),

    // to register interface (read)
    .qs(status1_accelerator_using_sram_qs)
  );


  //   F[reload_flag]: 3:3
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_reload_flag (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_reload_flag_we),
    .wd(status1_reload_flag_wd),

    // from internal hardware
    .de(hw2reg.status1.reload_flag.de),
    .d (hw2reg.status1.reload_flag.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.reload_flag.q),

    // to register interface (read)
    .qs(status1_reload_flag_qs)
  );


  //   F[done_calculation]: 4:4
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_done_calculation (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_done_calculation_we),
    .wd(status1_done_calculation_wd),

    // from internal hardware
    .de(hw2reg.status1.done_calculation.de),
    .d (hw2reg.status1.done_calculation.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.done_calculation.q),

    // to register interface (read)
    .qs(status1_done_calculation_qs)
  );


  //   F[done_filter]: 5:5
  prim_subreg #(
    .DW      (1),
    .SWACCESS("RW"),
    .RESVAL  (1'h0)
  ) u_status1_done_filter (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_done_filter_we),
    .wd(status1_done_filter_wd),

    // from internal hardware
    .de(hw2reg.status1.done_filter.de),
    .d (hw2reg.status1.done_filter.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.done_filter.q),

    // to register interface (read)
    .qs(status1_done_filter_qs)
  );


  //   F[filter_number_sram]: 10:8
  prim_subreg #(
    .DW      (3),
    .SWACCESS("RW"),
    .RESVAL  (3'h0)
  ) u_status1_filter_number_sram (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_filter_number_sram_we),
    .wd(status1_filter_number_sram_wd),

    // from internal hardware
    .de(hw2reg.status1.filter_number_sram.de),
    .d (hw2reg.status1.filter_number_sram.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.filter_number_sram.q),

    // to register interface (read)
    .qs(status1_filter_number_sram_qs)
  );


  //   F[data_number_sram]: 13:11
  prim_subreg #(
    .DW      (3),
    .SWACCESS("RW"),
    .RESVAL  (3'h0)
  ) u_status1_data_number_sram (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_data_number_sram_we),
    .wd(status1_data_number_sram_wd),

    // from internal hardware
    .de(hw2reg.status1.data_number_sram.de),
    .d (hw2reg.status1.data_number_sram.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.data_number_sram.q),

    // to register interface (read)
    .qs(status1_data_number_sram_qs)
  );


  //   F[lego_number_din]: 15:14
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_status1_lego_number_din (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_lego_number_din_we),
    .wd(status1_lego_number_din_wd),

    // from internal hardware
    .de(hw2reg.status1.lego_number_din.de),
    .d (hw2reg.status1.lego_number_din.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.lego_number_din.q),

    // to register interface (read)
    .qs(status1_lego_number_din_qs)
  );


  //   F[lego_number_weights]: 17:16
  prim_subreg #(
    .DW      (2),
    .SWACCESS("RW"),
    .RESVAL  (2'h0)
  ) u_status1_lego_number_weights (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_lego_number_weights_we),
    .wd(status1_lego_number_weights_wd),

    // from internal hardware
    .de(hw2reg.status1.lego_number_weights.de),
    .d (hw2reg.status1.lego_number_weights.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.lego_number_weights.q),

    // to register interface (read)
    .qs(status1_lego_number_weights_qs)
  );


  //   F[lego_tower_din]: 22:18
  prim_subreg #(
    .DW      (5),
    .SWACCESS("RW"),
    .RESVAL  (5'h0)
  ) u_status1_lego_tower_din (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status1_lego_tower_din_we),
    .wd(status1_lego_tower_din_wd),

    // from internal hardware
    .de(hw2reg.status1.lego_tower_din.de),
    .d (hw2reg.status1.lego_tower_din.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status1.lego_tower_din.q),

    // to register interface (read)
    .qs(status1_lego_tower_din_qs)
  );


  // R[status2]: V(False)

  //   F[din_address]: 7:0
  prim_subreg #(
    .DW      (8),
    .SWACCESS("RW"),
    .RESVAL  (8'h0)
  ) u_status2_din_address (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status2_din_address_we),
    .wd(status2_din_address_wd),

    // from internal hardware
    .de(hw2reg.status2.din_address.de),
    .d (hw2reg.status2.din_address.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status2.din_address.q),

    // to register interface (read)
    .qs(status2_din_address_qs)
  );


  //   F[dout_address]: 15:8
  prim_subreg #(
    .DW      (8),
    .SWACCESS("RW"),
    .RESVAL  (8'h0)
  ) u_status2_dout_address (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status2_dout_address_we),
    .wd(status2_dout_address_wd),

    // from internal hardware
    .de(hw2reg.status2.dout_address.de),
    .d (hw2reg.status2.dout_address.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status2.dout_address.q),

    // to register interface (read)
    .qs(status2_dout_address_qs)
  );


  //   F[weight_address]: 23:16
  prim_subreg #(
    .DW      (8),
    .SWACCESS("RW"),
    .RESVAL  (8'h0)
  ) u_status2_weight_address (
    .clk_i (clk_i),
    .rst_ni(rst_ni),

    // from register interface
    .we(status2_weight_address_we),
    .wd(status2_weight_address_wd),

    // from internal hardware
    .de(hw2reg.status2.weight_address.de),
    .d (hw2reg.status2.weight_address.d),

    // to internal hardware
    .qe(),
    .q (reg2hw.status2.weight_address.q),

    // to register interface (read)
    .qs(status2_weight_address_qs)
  );




  logic [2:0] addr_hit;
  always_comb begin
    addr_hit    = '0;
    addr_hit[0] = (reg_addr == CONV1D_CONTROL_CONTROL_OFFSET);
    addr_hit[1] = (reg_addr == CONV1D_CONTROL_STATUS1_OFFSET);
    addr_hit[2] = (reg_addr == CONV1D_CONTROL_STATUS2_OFFSET);
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
              ((addr_hit[0] & (|(CONV1D_CONTROL_PERMIT[0] & ~reg_be))) |
               (addr_hit[1] & (|(CONV1D_CONTROL_PERMIT[1] & ~reg_be))) |
               (addr_hit[2] & (|(CONV1D_CONTROL_PERMIT[2] & ~reg_be)))));
  end

  assign control_start_we                  = addr_hit[0] & reg_we & !reg_error;
  assign control_start_wd                  = reg_wdata[0];

  assign control_mcu_using_sram_we         = addr_hit[0] & reg_we & !reg_error;
  assign control_mcu_using_sram_wd         = reg_wdata[1];

  assign control_loaded_flag_we            = addr_hit[0] & reg_we & !reg_error;
  assign control_loaded_flag_wd            = reg_wdata[2];

  assign status1_running_we                = addr_hit[1] & reg_we & !reg_error;
  assign status1_running_wd                = reg_wdata[0];

  assign status1_done_we                   = addr_hit[1] & reg_we & !reg_error;
  assign status1_done_wd                   = reg_wdata[1];

  assign status1_accelerator_using_sram_we = addr_hit[1] & reg_we & !reg_error;
  assign status1_accelerator_using_sram_wd = reg_wdata[2];

  assign status1_reload_flag_we            = addr_hit[1] & reg_we & !reg_error;
  assign status1_reload_flag_wd            = reg_wdata[3];

  assign status1_done_calculation_we       = addr_hit[1] & reg_we & !reg_error;
  assign status1_done_calculation_wd       = reg_wdata[4];

  assign status1_done_filter_we            = addr_hit[1] & reg_we & !reg_error;
  assign status1_done_filter_wd            = reg_wdata[5];

  assign status1_filter_number_sram_we     = addr_hit[1] & reg_we & !reg_error;
  assign status1_filter_number_sram_wd     = reg_wdata[10:8];

  assign status1_data_number_sram_we       = addr_hit[1] & reg_we & !reg_error;
  assign status1_data_number_sram_wd       = reg_wdata[13:11];

  assign status1_lego_number_din_we        = addr_hit[1] & reg_we & !reg_error;
  assign status1_lego_number_din_wd        = reg_wdata[15:14];

  assign status1_lego_number_weights_we    = addr_hit[1] & reg_we & !reg_error;
  assign status1_lego_number_weights_wd    = reg_wdata[17:16];

  assign status1_lego_tower_din_we         = addr_hit[1] & reg_we & !reg_error;
  assign status1_lego_tower_din_wd         = reg_wdata[22:18];

  assign status2_din_address_we            = addr_hit[2] & reg_we & !reg_error;
  assign status2_din_address_wd            = reg_wdata[7:0];

  assign status2_dout_address_we           = addr_hit[2] & reg_we & !reg_error;
  assign status2_dout_address_wd           = reg_wdata[15:8];

  assign status2_weight_address_we         = addr_hit[2] & reg_we & !reg_error;
  assign status2_weight_address_wd         = reg_wdata[23:16];

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata_next[0] = control_start_qs;
        reg_rdata_next[1] = control_mcu_using_sram_qs;
        reg_rdata_next[2] = control_loaded_flag_qs;
      end

      addr_hit[1]: begin
        reg_rdata_next[0]     = status1_running_qs;
        reg_rdata_next[1]     = status1_done_qs;
        reg_rdata_next[2]     = status1_accelerator_using_sram_qs;
        reg_rdata_next[3]     = status1_reload_flag_qs;
        reg_rdata_next[4]     = status1_done_calculation_qs;
        reg_rdata_next[5]     = status1_done_filter_qs;
        reg_rdata_next[10:8]  = status1_filter_number_sram_qs;
        reg_rdata_next[13:11] = status1_data_number_sram_qs;
        reg_rdata_next[15:14] = status1_lego_number_din_qs;
        reg_rdata_next[17:16] = status1_lego_number_weights_qs;
        reg_rdata_next[22:18] = status1_lego_tower_din_qs;
      end

      addr_hit[2]: begin
        reg_rdata_next[7:0]   = status2_din_address_qs;
        reg_rdata_next[15:8]  = status2_dout_address_qs;
        reg_rdata_next[23:16] = status2_weight_address_qs;
      end

      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be    = ^reg_be;

  // Assertions for Register Interface
  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit))

endmodule
